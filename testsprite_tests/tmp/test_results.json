[
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "dc272171-401b-4540-b38a-00675320a483",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC001-test user authentication and role based route protection",
    "description": "Verify that the authentication system using Supabase Auth correctly allows users to login and logout, and that route protection based on user roles (Gerente Geral and Chefe de Equipe) properly restricts access to authorized pages only.",
    "code": "import requests\nimport base64\n\nBASE_URL = \"http://localhost:5174\"\n\nAPI_KEY = \"your-api-key\"  # Replace with valid API key\nTIMEOUT = 30\n\n# Supabase Auth endpoints assumed:\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nLOGIN_ENDPOINT = f\"{AUTH_URL}/token\"\nUSER_ENDPOINT = f\"{AUTH_URL}/user\"\n\nheaders_api_key = {\n    \"apikey\": API_KEY,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_user_authentication_and_role_based_route_protection():\n    # Test users with roles: Gerente Geral and Chefe de Equipe\n    # For testing, use two users credentials (assumed available for test environment)\n    USERS = {\n        \"gerente_geral\": {\n            \"email\": \"gerente.geral@example.com\",\n            \"password\": \"TestPass123!\"\n        },\n        \"chefe_de_equipe\": {\n            \"email\": \"chefe.equipe@example.com\",\n            \"password\": \"TestPass123!\"\n        }\n    }\n\n    session_tokens = {}\n\n    try:\n        # 1. Login each user and check access to dashboard routes based on roles\n        for role, creds in USERS.items():\n            # Login request to Supabase Auth (POST /token with grant_type=password)\n            login_payload = {\n                \"grant_type\": \"password\",\n                \"email\": creds[\"email\"],\n                \"password\": creds[\"password\"]\n            }\n            # Correct Authorization header with Basic base64 encoded anon key (Supabase expects this for /token)\n            basic_auth = base64.b64encode(f\"{API_KEY}:\".encode()).decode()\n            login_headers = {\n                \"Authorization\": f\"Basic {basic_auth}\",\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Accept\": \"application/json\"\n            }\n\n            response = requests.post(\n                LOGIN_ENDPOINT,\n                data=login_payload,\n                headers=login_headers,\n                timeout=TIMEOUT\n            )\n\n            assert response.status_code == 200, f\"Login failed for {role}\"\n            login_data = response.json()\n            assert \"access_token\" in login_data, f\"access_token missing for {role}\"\n            access_token = login_data[\"access_token\"]\n            session_tokens[role] = access_token\n\n            # Validate user metadata role by fetching user info\n            user_headers = {\n                \"Authorization\": f\"Bearer {access_token}\",\n                \"apikey\": API_KEY,\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\"\n            }\n            user_response = requests.get(USER_ENDPOINT, headers=user_headers, timeout=TIMEOUT)\n            assert user_response.status_code == 200, f\"User info fetch failed for {role}\"\n            user_info = user_response.json()\n            # Check role presence (assuming role stored in user_metadata with key 'role')\n            assert \"user_metadata\" in user_info, f\"user_metadata missing for {role}\"\n            user_role = user_info[\"user_metadata\"].get(\"role\")\n            assert user_role in [\"Gerente Geral\", \"Chefe de Equipe\"], f\"Unexpected role for {role}: {user_role}\"\n            # Role must match expected role for test user\n            expected_role_name = \"Gerente Geral\" if role == \"gerente_geral\" else \"Chefe de Equipe\"\n            assert user_role == expected_role_name, f\"Role mismatch for {role} user\"\n\n        # 2. Role-based route protection access check\n        # Gerente Geral should access /dashboard-gerente and /user-management (admin functions)\n        gerente_headers = {\n            \"Authorization\": f\"Bearer {session_tokens['gerente_geral']}\",\n            \"apikey\": API_KEY\n        }\n        gerente_dashboard_resp = requests.get(f\"{BASE_URL}/dashboard-gerente\", headers=gerente_headers, timeout=TIMEOUT)\n        assert gerente_dashboard_resp.status_code == 200, \"Gerente Geral cannot access /dashboard-gerente\"\n\n        user_management_resp = requests.get(f\"{BASE_URL}/usuarios\", headers=gerente_headers, timeout=TIMEOUT)\n        assert user_management_resp.status_code == 200, \"Gerente Geral cannot access /usuarios (user management)\"\n\n        # Gerente Geral should also be able to logout\n        logout_resp_gerente = requests.post(f\"{AUTH_URL}/logout\", headers={\"Authorization\": f\"Bearer {session_tokens['gerente_geral']}\", \"apikey\": API_KEY}, timeout=TIMEOUT)\n        assert logout_resp_gerente.status_code in [200, 204], \"Gerente Geral logout failed\"\n\n        # Chefe de Equipe should access only /dashboard-chefe and restricted areas\n        chefe_headers = {\n            \"Authorization\": f\"Bearer {session_tokens['chefe_de_equipe']}\",\n            \"apikey\": API_KEY\n        }\n        chefe_dashboard_resp = requests.get(f\"{BASE_URL}/dashboard-chefe\", headers=chefe_headers, timeout=TIMEOUT)\n        assert chefe_dashboard_resp.status_code == 200, \"Chefe de Equipe cannot access /dashboard-chefe\"\n\n        # Attempting to access admin/user management should be forbidden or unauthorized\n        chefe_user_management_resp = requests.get(f\"{BASE_URL}/usuarios\", headers=chefe_headers, timeout=TIMEOUT)\n        assert chefe_user_management_resp.status_code in [401, 403], \"Chefe de Equipe improperly accessed /usuarios\"\n\n        # Chefe de Equipe logout\n        logout_resp_chefe = requests.post(f\"{AUTH_URL}/logout\", headers={\"Authorization\": f\"Bearer {session_tokens['chefe_de_equipe']}\", \"apikey\": API_KEY}, timeout=TIMEOUT)\n        assert logout_resp_chefe.status_code in [200, 204], \"Chefe de Equipe logout failed\"\n\n    except requests.RequestException as e:\n        assert False, f\"RequestException during test: {e}\"\n\n\ntest_user_authentication_and_role_based_route_protection()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 60, in test_user_authentication_and_role_based_route_protection\nAssertionError: Login failed for gerente_geral\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.772Z",
    "modified": "2026-01-29T04:43:14.490Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "7d5067b7-030a-46c1-b1a0-6bab97c73aec",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC002-test gerente geral dashboard access and functionality",
    "description": "Ensure that the Dashboard Gerente page loads correctly for users with Gerente Geral role and that all administrative functionalities are accessible and operational.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# These should be replaced with valid tokens for a user with Gerente Geral role and a valid API key for the service.\nBEARER_TOKEN = \"your_valid_gerente_geral_bearer_token\"\nAPI_KEY = \"your_valid_api_key\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Accept\": \"application/json\",\n}\n\ndef test_gerente_geral_dashboard_access_and_functionality():\n    try:\n        # Access Dashboard Gerente main page data endpoint\n        dashboard_url = f\"{BASE_URL}/api/dashboard/gerente\"\n        resp = requests.get(dashboard_url, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        dashboard_data = resp.json()\n\n        # Check response basic structure and keys expected for Gerente Geral dashboard\n        assert isinstance(dashboard_data, dict), \"Dashboard data should be a JSON object\"\n        # Expect keys indicating administrative panels and stats are present\n        expected_keys = [\n            \"userRole\", \"panels\", \"analyticsSummary\", \"userManagementAccess\", \n            \"colaboradoresManagementAccess\", \"complianceAlerts\", \"historicalLaunches\"\n        ]\n        for key in expected_keys:\n            assert key in dashboard_data, f\"Expected key '{key}' in dashboard data\"\n\n        # Validate user role is \"Gerente Geral\"\n        assert dashboard_data.get(\"userRole\") == \"Gerente Geral\", \"User role should be Gerente Geral\"\n\n        # Check administrative functionalities accessibility flags are True\n        assert dashboard_data.get(\"userManagementAccess\") is True, \"User management access must be granted\"\n        assert dashboard_data.get(\"colaboradoresManagementAccess\") is True, \"Colaboradores management access must be granted\"\n\n        # Check analyticsSummary has expected sub-keys generally present\n        analytics_keys = [\"kpis\", \"charts\", \"alerts\"]\n        analytics_summary = dashboard_data.get(\"analyticsSummary\", {})\n        for key in analytics_keys:\n            assert key in analytics_summary, f\"Analytics summary missing '{key}'\"\n\n        # Check compliance alerts structure if present\n        compliance_alerts = dashboard_data.get(\"complianceAlerts\", [])\n        assert isinstance(compliance_alerts, list), \"Compliance alerts should be a list\"\n\n        # Verify historicalLaunches pagination info or list\n        historical = dashboard_data.get(\"historicalLaunches\")\n        assert historical is not None, \"Historical launches section must be present\"\n\n        # Optionally, test an admin operation endpoint access (like listing users)\n        users_url = f\"{BASE_URL}/api/admin/users\"\n        users_resp = requests.get(users_url, headers=HEADERS, timeout=TIMEOUT)\n        users_resp.raise_for_status()\n        users_data = users_resp.json()\n        assert isinstance(users_data, list), \"Users data should be a list\"\n        assert len(users_data) >= 0, \"Users list should be present\"\n\n    except requests.exceptions.HTTPError as http_err:\n        assert False, f\"HTTP error occurred: {http_err}\"\n    except requests.exceptions.RequestException as req_err:\n        assert False, f\"Request error occurred: {req_err}\"\n    except AssertionError:\n        raise\n    except Exception as err:\n        assert False, f\"Unexpected error occurred: {err}\"\n\ntest_gerente_geral_dashboard_access_and_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in test_gerente_geral_dashboard_access_and_functionality\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:5174/api/dashboard/gerente\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 64, in test_gerente_geral_dashboard_access_and_functionality\nAssertionError: HTTP error occurred: 404 Client Error: Not Found for url: http://localhost:5174/api/dashboard/gerente\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.779Z",
    "modified": "2026-01-29T04:42:41.808Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "4cbb264f-d49e-404a-b751-ed22432b74e0",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC003-test chefe de equipe dashboard access and restrictions",
    "description": "Verify that the Dashboard Chefe page loads correctly for users with Chefe de Equipe role and that access is limited to the specific functionalities allowed for this role.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# Replace these with valid credentials or tokens for a user with Chefe de Equipe role\nBEARER_TOKEN = \"your_valid_chefe_de_equipe_bearer_token_here\"\nAPI_KEY = \"your_valid_api_key_here\"\n\ndef test_chefe_de_equipe_dashboard_access_and_restrictions():\n    headers = {\n        \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n        \"x-api-key\": API_KEY,\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        # Access Dashboard Chefe page endpoint (assuming /dashboard/chefe as standard REST endpoint)\n        response = requests.get(f\"{BASE_URL}/dashboard/chefe\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n\n        data = response.json()\n\n        # Validate dashboard keys that should be present for Chefe de Equipe role\n        required_keys = [\n            \"operational_view\",\n            \"launch_history\",\n            \"analytics_module_link\",\n            \"restricted_access_confirmed\"\n        ]\n\n        for key in required_keys:\n            assert key in data, f\"Missing required dashboard key: {key}\"\n\n        # Check that restricted functionalities are not accessible\n        # For example, no 'user_management' or 'full_admin_controls' keys\n        forbidden_keys = [\n            \"user_management\",\n            \"full_admin_controls\",\n            \"gerente_features\"\n        ]\n\n        for key in forbidden_keys:\n            assert key not in data, f\"Restricted functionality '{key}' should not be accessible by Chefe de Equipe\"\n\n        # Additionally, verify role in response if available\n        role = data.get(\"user_role\")\n        assert role == \"Chefe de Equipe\", f\"Expected role 'Chefe de Equipe', got '{role}'\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    except ValueError as ve:\n        assert False, f\"Invalid JSON response: {ve}\"\n\ntest_chefe_de_equipe_dashboard_access_and_restrictions()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 55, in <module>\n  File \"<string>\", line 20, in test_chefe_de_equipe_dashboard_access_and_restrictions\nAssertionError: Expected 200 OK, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.786Z",
    "modified": "2026-01-29T04:42:39.079Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "4ec1aab3-ef8b-4fb2-a169-8c5008bbbc7b",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC004-test analytics dashboard filters and data visualization",
    "description": "Test the Dashboard Analytics page with various filters (base, equipe, periodo, colaborador, tipos de ocorrencia) to ensure correct data retrieval, processing, and display of KPIs, charts, and rankings.",
    "code": "import requests\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:5174\"\nAPI_KEY = \"your_api_key_here\"\nBEARER_TOKEN = \"your_bearer_token_here\"\nTIMEOUT = 30\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_analytics_dashboard_filters_and_data_visualization():\n    \"\"\"\n    Test the Dashboard Analytics page with various filters:\n    base, equipe, periodo, colaborador, tipos de ocorrencia.\n    Validate correct data retrieval, KPIs, charts, and rankings.\n    \"\"\"\n    # Prepare filter parameters for testing\n    base_id = 1  # Example base id\n    equipe_id = 1  # Example equipe id\n    colaborador_id = 1  # Example colaborador id\n    tipo_ocorrencia_aeronautica = \"Aeronáutica\"\n    tipo_ocorrencia_nao_aeronautica = \"Não Aeronáutica\"\n\n    # Period filter - last 30 days (within 12 months limit)\n    end_date = datetime.utcnow().date()\n    start_date = end_date - timedelta(days=30)\n    period = f\"{start_date.isoformat()}_{end_date.isoformat()}\"\n\n    # Define API endpoint for analytics data\n    analytics_endpoint = f\"{BASE_URL}/api/analytics/dashboard\"\n\n    # Define multiple filter sets to test behavior\n    filter_sets = [\n        {\"base\": base_id},\n        {\"equipe\": equipe_id},\n        {\"periodo\": period},\n        {\"colaborador\": colaborador_id},\n        {\"tiposOcorrencia\": [tipo_ocorrencia_aeronautica]},\n        {\"tiposOcorrencia\": [tipo_ocorrencia_nao_aeronautica]},\n        {\n            \"base\": base_id,\n            \"equipe\": equipe_id,\n            \"periodo\": period,\n            \"colaborador\": colaborador_id,\n            \"tiposOcorrencia\": [tipo_ocorrencia_aeronautica]\n        }\n    ]\n\n    for filters in filter_sets:\n        # For GET params, convert list filters to comma-separated strings\n        params = {}\n        for k, v in filters.items():\n            if isinstance(v, list):\n                params[k] = \",\".join(v)\n            else:\n                params[k] = v\n\n        # Send GET request with filters as query params\n        response = requests.get(\n            analytics_endpoint,\n            headers=HEADERS,\n            params=params,\n            timeout=TIMEOUT\n        )\n\n        # Validate HTTP status code\n        assert response.status_code == 200, (\n            f\"Failed for filters {filters}: \"\n            f\"Status code {response.status_code}, Response: {response.text}\"\n        )\n\n        data = response.json()\n\n        # Validate presence of expected keys in response for dashboard analytics\n        assert \"kpis\" in data, f\"KPIs missing in response for filters {filters}\"\n        assert isinstance(data[\"kpis\"], dict), f\"KPIs should be a dict for filters {filters}\"\n\n        assert \"charts\" in data, f\"Charts missing in response for filters {filters}\"\n        assert isinstance(data[\"charts\"], dict), f\"Charts should be a dict for filters {filters}\"\n\n        assert \"ranking\" in data, f\"Ranking missing in response for filters {filters}\"\n        assert isinstance(data[\"ranking\"], list), f\"Ranking should be a list for filters {filters}\"\n\n        # Validate KPIs numeric and non-negative\n        for kpi_key, kpi_value in data[\"kpis\"].items():\n            assert isinstance(kpi_value, (int, float)), f\"KPI {kpi_key} should be numeric\"\n            assert kpi_value >= 0, f\"KPI {kpi_key} should be non-negative\"\n\n        # Validate charts contain expected keys and data\n        for chart_key, chart_data in data[\"charts\"].items():\n            assert isinstance(chart_data, dict), f\"Chart {chart_key} should be dict\"\n            assert \"data\" in chart_data, f\"Chart {chart_key} missing 'data' key\"\n            assert isinstance(chart_data[\"data\"], list), f\"Chart {chart_key} data should be a list\"\n\n            # If data points have time-series info, check chronological order if possible\n            if len(chart_data[\"data\"]) > 1 and \"date\" in chart_data[\"data\"][0]:\n                dates = [point.get(\"date\") for point in chart_data[\"data\"] if \"date\" in point]\n                assert dates == sorted(dates), f\"Chart {chart_key} dates not sorted\"\n\n        # Validate ranking list sorted descending by alert count/key metric if present\n        if len(data[\"ranking\"]) > 1:\n            prev_value = None\n            for item in data[\"ranking\"]:\n                assert \"alertCount\" in item or \"metric\" in item, \"Ranking item lacks alertCount or metric\"\n                current_value = item.get(\"alertCount\", item.get(\"metric\", 0))\n                assert isinstance(current_value, (int, float)), \"Ranking metric not numeric\"\n                if prev_value is not None:\n                    assert current_value <= prev_value, \"Ranking not in descending order\"\n                prev_value = current_value\n\ntest_analytics_dashboard_filters_and_data_visualization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 76, in test_analytics_dashboard_filters_and_data_visualization\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.791Z",
    "modified": "2026-01-29T04:42:59.022Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "6e8fb588-44b5-4657-b3aa-8be5832a6229",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC005-test user management crud operations",
    "description": "Validate the complete CRUD operations for user management including individual and bulk user creation, editing, listing, and deletion with proper form validation and role-based access.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# Authentication tokens (these should be valid for the test environment)\nBEARER_TOKEN = \"your_bearer_token_here\"\nAPI_KEY = \"your_api_key_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_user_management_crud_operations():\n    created_user_ids = []\n\n    def create_user(payload):\n        response = requests.post(\n            f\"{BASE_URL}/api/users\",\n            headers=HEADERS,\n            json=payload,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        user_data = response.json()\n        assert \"id\" in user_data, \"User ID not returned on creation\"\n        created_user_ids.append(user_data[\"id\"])\n        return user_data\n\n    def bulk_create_users(users_payload):\n        response = requests.post(\n            f\"{BASE_URL}/api/users/bulk\",\n            headers=HEADERS,\n            json=users_payload,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        bulk_data = response.json()\n        assert isinstance(bulk_data, list) and len(bulk_data) == len(users_payload), \"Bulk creation failed or incomplete\"\n        ids = [user.get(\"id\") for user in bulk_data if \"id\" in user]\n        created_user_ids.extend(ids)\n        return bulk_data\n\n    def list_users():\n        response = requests.get(\n            f\"{BASE_URL}/api/users\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        users_list = response.json()\n        assert isinstance(users_list, list), \"User listing did not return a list\"\n        return users_list\n\n    def get_user(user_id):\n        response = requests.get(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        user = response.json()\n        assert user.get(\"id\") == user_id, \"Fetched user ID mismatch\"\n        return user\n\n    def update_user(user_id, update_payload):\n        response = requests.put(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            headers=HEADERS,\n            json=update_payload,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        updated_user = response.json()\n        assert updated_user.get(\"id\") == user_id, \"Updated user ID mismatch\"\n        return updated_user\n\n    def delete_user(user_id):\n        response = requests.delete(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # For delete, 204 No Content or 200 OK expected\n        assert response.status_code in (200, 204), f\"Failed to delete user {user_id}\"\n\n    def test_form_validation_invalid_user_creation():\n        invalid_payloads = [\n            {},  # Empty payload\n            {\"email\": \"not-an-email\", \"name\": \"Test User\", \"role\": \"Gerente Geral\"},  # Invalid email\n            {\"email\": \"valid@example.com\", \"name\": \"\", \"role\": \"Chefe de Equipe\"},  # Empty name\n            {\"email\": \"valid@example.com\", \"name\": \"Test User\", \"role\": \"InvalidRole\"}  # Invalid role\n        ]\n        for payload in invalid_payloads:\n            resp = requests.post(\n                f\"{BASE_URL}/api/users\",\n                headers=HEADERS,\n                json=payload,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code == 400, f\"Invalid user payload should return 400, got {resp.status_code}\"\n\n    # Begin test logic\n    try:\n        # 1. Test individual user creation\n        user_payload = {\n            \"email\": f\"user{str(uuid.uuid4())[:8]}@example.com\",\n            \"name\": \"User Test\",\n            \"role\": \"Gerente Geral\"\n        }\n        created_user = create_user(user_payload)\n        user_id = created_user[\"id\"]\n\n        # 2. Test fetching the created user\n        fetched_user = get_user(user_id)\n        assert fetched_user[\"email\"] == user_payload[\"email\"]\n        assert fetched_user[\"name\"] == user_payload[\"name\"]\n        assert fetched_user[\"role\"] == user_payload[\"role\"]\n\n        # 3. Test update user\n        update_payload = {\n            \"name\": \"User Test Updated\",\n            \"role\": \"Chefe de Equipe\"\n        }\n        updated_user = update_user(user_id, update_payload)\n        assert updated_user[\"name\"] == update_payload[\"name\"]\n        assert updated_user[\"role\"] == update_payload[\"role\"]\n\n        # 4. Test list users includes the created user\n        users = list_users()\n        assert any(u[\"id\"] == user_id for u in users), \"Created user not found in listing\"\n\n        # 5. Test bulk user creation\n        bulk_users_payload = [\n            {\n                \"email\": f\"bulkuser{str(uuid.uuid4())[:8]}@example.com\",\n                \"name\": \"Bulk User One\",\n                \"role\": \"Gerente Geral\"\n            },\n            {\n                \"email\": f\"bulkuser{str(uuid.uuid4())[:8]}@example.com\",\n                \"name\": \"Bulk User Two\",\n                \"role\": \"Chefe de Equipe\"\n            }\n        ]\n        bulk_created = bulk_create_users(bulk_users_payload)\n        assert len(bulk_created) == 2\n\n        # 6. Validate each bulk user data (basic checks)\n        for i, user in enumerate(bulk_created):\n            assert user[\"email\"] == bulk_users_payload[i][\"email\"]\n            assert user[\"role\"] == bulk_users_payload[i][\"role\"]\n\n        # 7. Test form validation for creation with invalid data\n        test_form_validation_invalid_user_creation()\n\n        # 8. Test role-based access: try to edit user with invalid role or missing permissions\n        # For this test, we assume API returns 403 Forbidden if role lacks permission\n        # Here we simulate by sending an invalid role in update and expect 400 validation failure already done above\n        # So, simulate an unauthorized action by removing / changing token headers would be environment specific\n        # Hence only a placeholder check for the purpose of demonstration\n\n        # 9. Clean-up individual and bulk users (done in finally)\n\n    finally:\n        # Cleanup created users\n        for uid in created_user_ids:\n            try:\n                delete_user(uid)\n            except Exception:\n                # If deletion failed, continue cleaning others\n                pass\n\ntest_user_management_crud_operations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 177, in <module>\n  File \"<string>\", line 114, in test_user_management_crud_operations\n  File \"<string>\", line 27, in create_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:5174/api/users\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.797Z",
    "modified": "2026-01-29T04:42:42.146Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "b2db059a-fd87-4a42-957e-f2a4b703bdba",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC006-test colaborador management functionality",
    "description": "Verify the CRUD operations for managing colaboradores/bombeiros including individual and batch additions, edits, and removals, ensuring correct association with bases and teams.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# Authentication tokens (replace with valid tokens for real testing)\nBEARER_TOKEN = \"your_valid_bearer_token_here\"\nAPI_KEY = \"your_valid_api_key_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\n\ndef test_colaborador_management_functionality():\n    colaborador_id = None\n    batch_ids = []\n    base_id = None\n    equipe_id = None\n\n    try:\n        # 1. Create a base to associate colaboradores\n        base_payload = {\n            \"nome\": \"Base Teste API\",\n            \"localizacao\": \"Location Teste\"\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/bases\",\n            json=base_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Base creation failed: {resp.text}\"\n        base = resp.json()\n        base_id = base.get(\"id\")\n        assert base_id is not None, \"Base ID not returned\"\n        assert base.get(\"nome\") == base_payload[\"nome\"]\n\n        # 2. Create a team (equipe) to associate colaboradores\n        equipe_payload = {\n            \"nome\": \"Equipe Teste API\",\n            \"base_id\": base_id\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/equipes\",\n            json=equipe_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Equipe creation failed: {resp.text}\"\n        equipe = resp.json()\n        equipe_id = equipe.get(\"id\")\n        assert equipe_id is not None, \"Equipe ID not returned\"\n        assert equipe.get(\"nome\") == equipe_payload[\"nome\"]\n        assert equipe.get(\"base_id\") == base_id\n\n        # 3. Create individual colaborador\n        colaborador_payload = {\n            \"nome\": \"Colaborador Teste\",\n            \"email\": \"colaborador.teste@example.com\",\n            \"base_id\": base_id,\n            \"equipe_id\": equipe_id,\n            \"role\": \"bombeiro\"\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/colaboradores\",\n            json=colaborador_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Colaborador creation failed: {resp.text}\"\n        colaborador = resp.json()\n        colaborador_id = colaborador.get(\"id\")\n        assert colaborador_id is not None, \"Colaborador ID not returned\"\n        assert colaborador.get(\"nome\") == colaborador_payload[\"nome\"]\n        assert colaborador.get(\"email\") == colaborador_payload[\"email\"]\n        assert colaborador.get(\"base_id\") == base_id\n        assert colaborador.get(\"equipe_id\") == equipe_id\n\n        # 4. Edit the colaborador\n        update_payload = {\n            \"nome\": \"Colaborador Teste Editado\",\n            \"email\": \"colaborador.editado@example.com\"\n        }\n        resp = requests.put(\n            f\"{BASE_URL}/colaboradores/{colaborador_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Colaborador update failed: {resp.text}\"\n        updated = resp.json()\n        assert updated.get(\"nome\") == update_payload[\"nome\"]\n        assert updated.get(\"email\") == update_payload[\"email\"]\n\n        # 5. Batch add colaboradores (simulate batch addition)\n        batch_payload = {\n            \"colaboradores\": [\n                {\n                    \"nome\": \"Batch Colaborador 1\",\n                    \"email\": \"batch1@example.com\",\n                    \"base_id\": base_id,\n                    \"equipe_id\": equipe_id,\n                    \"role\": \"bombeiro\"\n                },\n                {\n                    \"nome\": \"Batch Colaborador 2\",\n                    \"email\": \"batch2@example.com\",\n                    \"base_id\": base_id,\n                    \"equipe_id\": equipe_id,\n                    \"role\": \"bombeiro\"\n                }\n            ]\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/colaboradores/batch\",\n            json=batch_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Batch creation failed: {resp.text}\"\n        batch_created = resp.json()\n        assert isinstance(batch_created, list) and len(batch_created) == 2, \"Batch creation returned invalid data\"\n        for c in batch_created:\n            batch_ids.append(c.get(\"id\"))\n            assert c.get(\"base_id\") == base_id\n            assert c.get(\"equipe_id\") == equipe_id\n\n        # 6. Edit one from batch\n        if batch_ids:\n            edit_id = batch_ids[0]\n            edit_payload = {\n                \"nome\": \"Batch Colaborador 1 Editado\",\n                \"email\": \"batch1.editado@example.com\"\n            }\n            resp = requests.put(\n                f\"{BASE_URL}/colaboradores/{edit_id}\",\n                json=edit_payload,\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code == 200, f\"Batch colaborador update failed: {resp.text}\"\n            edited = resp.json()\n            assert edited.get(\"nome\") == edit_payload[\"nome\"]\n            assert edited.get(\"email\") == edit_payload[\"email\"]\n\n        # 7. List colaboradores filtered by base and equipe\n        params = {\"base_id\": base_id, \"equipe_id\": equipe_id}\n        resp = requests.get(\n            f\"{BASE_URL}/colaboradores\",\n            headers=HEADERS,\n            params=params,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Colaboradores listing failed: {resp.text}\"\n        colaboradores_list = resp.json()\n        assert isinstance(colaboradores_list, list)\n        ids_listed = [c.get(\"id\") for c in colaboradores_list]\n        assert colaborador_id in ids_listed\n        for bid in batch_ids:\n            assert bid in ids_listed\n\n        # 8. Delete individual colaborador\n        resp = requests.delete(\n            f\"{BASE_URL}/colaboradores/{colaborador_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 204, f\"Colaborador deletion failed: {resp.text}\"\n        colaborador_id = None  # Mark as deleted\n\n        # 9. Batch delete colaboradores\n        for bid in batch_ids:\n            resp = requests.delete(\n                f\"{BASE_URL}/colaboradores/{bid}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code == 204, f\"Batch colaborador deletion failed for id {bid}: {resp.text}\"\n        batch_ids = []\n\n    finally:\n        # Cleanup in case of failure or partial success\n        if colaborador_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/colaboradores/{colaborador_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n        for bid in batch_ids:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/colaboradores/{bid}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n        if equipe_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/equipes/{equipe_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n        if base_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/bases/{base_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\n\ntest_colaborador_management_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 224, in <module>\n  File \"<string>\", line 35, in test_colaborador_management_functionality\nAssertionError: Base creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.804Z",
    "modified": "2026-01-29T04:43:40.954Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "5d44d2a1-2ad2-4cd2-ad89-bbcf88de6295",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC007-test compliance monitoring and adherence alerts",
    "description": "Check the compliance and adherence monitoring system for bases and indicators, ensuring that visual alerts for non-compliance and inactive users are displayed correctly according to defined rules.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5174\"\nAPI_KEY = \"your_api_key_here\"  # Replace with a valid API key\nBEARER_TOKEN = \"your_bearer_token_here\"  # Replace with a valid Bearer token\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_compliance_monitoring_and_adherence_alerts():\n    \"\"\"\n    Check the compliance and adherence monitoring system for bases and indicators,\n    ensuring that visual alerts for non-compliance and inactive users are displayed correctly.\n    \"\"\"\n    compliance_endpoint = f\"{BASE_URL}/monitoramento/aderencia\"  # assumed endpoint for adherence monitoring\n    \n    try:\n        response = requests.get(compliance_endpoint, headers=HEADERS, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to compliance monitoring endpoint failed: {e}\"\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    assert \"application/json\" in content_type.lower(), f\"Expected 'application/json' content type, got '{content_type}'\"\n\n    content_text = response.text.strip()\n    assert content_text != \"\", \"Response content is empty\"\n\n    try:\n        data = response.json()\n    except ValueError as e:\n        assert False, f\"Response is not valid JSON: {e}\"\n\n    assert isinstance(data, (dict, list)), \"Response JSON root should be dict or list\"\n\n    alert_keys = {\"baseId\", \"baseName\", \"complianceStatus\", \"alerts\", \"inactiveUsers\"}\n\n    if isinstance(data, dict):\n        present_keys = set(data.keys())\n        assert alert_keys.intersection(present_keys), f\"Expected keys {alert_keys} not found in response\"\n        alerts = data.get(\"alerts\")\n        inactive_users = data.get(\"inactiveUsers\")\n        assert alerts is not None, \"Expected 'alerts' in response\"\n        assert inactive_users is not None, \"Expected 'inactiveUsers' in response\"\n    elif isinstance(data, list):\n        assert len(data) > 0, \"Compliance data list is empty\"\n        for entry in data:\n            assert isinstance(entry, dict), \"Each compliance entry must be a dict\"\n            present_keys = set(entry.keys())\n            assert alert_keys.intersection(present_keys), f\"Expected keys {alert_keys} not found in entry\"\n            alerts = entry.get(\"alerts\")\n            inactive_users = entry.get(\"inactiveUsers\")\n            assert alerts is not None, \"'alerts' field missing in compliance entry\"\n            assert inactive_users is not None, \"'inactiveUsers' field missing in compliance entry\"\n            assert isinstance(alerts, (list, dict)), \"'alerts' should be list or dict\"\n            assert isinstance(inactive_users, (int, list, dict)), \"'inactiveUsers' should be int, list or dict\"\n    else:\n        assert False, \"Unexpected response format for compliance data\"\n\n    non_compliant_found = False\n    if isinstance(data, dict):\n        if data.get(\"complianceStatus\") and data[\"complianceStatus\"].lower() == \"non-compliant\":\n            non_compliant_found = True\n    else:\n        for entry in data:\n            status = entry.get(\"complianceStatus\", \"\").lower()\n            if status == \"non-compliant\":\n                non_compliant_found = True\n                break\n\n\ntest_compliance_monitoring_and_adherence_alerts()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 77, in <module>\n  File \"<string>\", line 29, in test_compliance_monitoring_and_adherence_alerts\nAssertionError: Expected 'application/json' content type, got 'text/html'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.810Z",
    "modified": "2026-01-29T04:43:03.389Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "8b1ff3ab-9f22-4bee-9c21-f62c00817a1d",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC008-test indicator data submission forms validation and submission",
    "description": "Test all indicator data submission forms for correct validation using Zod schemas, proper handling of date and time masks, and successful data submission to the backend.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# Authentication tokens (to be replaced with valid tokens for the test environment)\nBEARER_TOKEN = \"your_bearer_token_here\"\nAPI_KEY = \"your_api_key_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\n\ndef test_indicator_data_submission_forms_validation_and_submission():\n    \"\"\"\n    Test all indicator data submission forms for correct validation using Zod schemas,\n    proper handling of date and time masks, and successful data submission to the backend.\n    \"\"\"\n\n    # Define example valid payloads for indicators submitted via forms\n    # Assuming typical fields common to indicator submission forms:\n    # - date fields in ISO format\n    # - time fields in HH:mm format or combined with date\n    # - numeric or string fields validated by Zod schemas in backend\n\n    # For demonstration, we create sample payloads for some common indicators.\n    # These payloads must be adapted based on actual schema definitions.\n\n    indicator_forms_payloads = [\n        # Example: TAF indicator form submission payload\n        {\n            \"endpoint\": \"/api/lancamentos/taf\",\n            \"payload\": {\n                \"data\": datetime.date.today().isoformat(),  # date field\n                \"hora_inicio\": \"08:00\",                     # time mask as string HH:mm\n                \"hora_fim\": \"12:00\",\n                \"quantidade\": 5,                            # numeric field\n                \"obs\": \"Teste de submissao TAF\"\n            }\n        },\n        # Example: Prova Teórica indicator form payload\n        {\n            \"endpoint\": \"/api/lancamentos/prova-teorica\",\n            \"payload\": {\n                \"data\": datetime.date.today().isoformat(),\n                \"num_aprovados\": 10,\n                \"num_reprovados\": 2,\n                \"observacoes\": \"Submissao teste Prova Teorica\"\n            }\n        },\n        # Example: Ocorrência Aeronáutica indicator form payload\n        {\n            \"endpoint\": \"/api/lancamentos/ocorrencia-aeronautica\",\n            \"payload\": {\n                \"data\": datetime.date.today().isoformat(),\n                \"tipo_ocorrencia\": \"Incidente\",\n                \"descricao\": \"Teste Ocorrencia Aeronautica\",\n                \"horario\": \"14:30\"\n            }\n        },\n        # Example: Horas de Treinamento indicator form payload\n        {\n            \"endpoint\": \"/api/lancamentos/horas-treinamento\",\n            \"payload\": {\n                \"data\": datetime.date.today().isoformat(),\n                \"horas\": 3.5,\n                \"instrutor\": \"Instrutor Teste\",\n                \"descricao\": \"Teste Horas Treinamento\"\n            }\n        }\n        # Add more form payloads as needed to cover all indicators...\n    ]\n\n    created_ids = []  # To store IDs for cleanup\n\n    try:\n        for form in indicator_forms_payloads:\n            url = BASE_URL + form[\"endpoint\"]\n            payload = form[\"payload\"]\n\n            # Step 1: Test server-side validation by sending wrong format and expect 400 or specific validation error\n            # For example, sending wrong date format and invalid time format\n\n            invalid_payload = payload.copy()\n\n            # Inject date error (invalid date)\n            invalid_payload[\"data\"] = \"2023-02-30\"  # Invalid date\n\n            # Inject invalid time mask if field present (looks for keys containing \"hora\" or \"horario\")\n            for k in payload.keys():\n                if \"hora\" in k or \"horario\" in k:\n                    invalid_payload[k] = \"25:61\"\n\n            response_invalid = requests.post(url, json=invalid_payload, headers=HEADERS, timeout=TIMEOUT)\n            assert response_invalid.status_code == 400 or response_invalid.status_code == 422, (\n                f\"Expected validation error for invalid payload at {url}, got {response_invalid.status_code}\"\n            )\n            assert \"validation\" in response_invalid.text.lower() or \"error\" in response_invalid.text.lower()\n\n            # Step 2: Test successful submission with valid payload\n            response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n            assert response.status_code == 201 or response.status_code == 200, (\n                f\"Expected success status on valid submission at {url}, got {response.status_code}\"\n            )\n            data = response.json()\n            assert \"id\" in data, \"Response missing 'id' field on successful creation\"\n            created_ids.append((url, data[\"id\"]))\n\n        # Additional validations\n\n        # Test that multiple submissions on the same day for a given indicator are allowed (idempotent inserts)\n        # Using the first form as example\n        test_form = indicator_forms_payloads[0]\n        url = BASE_URL + test_form[\"endpoint\"]\n        payload = test_form[\"payload\"]\n        response_repeat = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response_repeat.status_code in (200, 201), \"Multiple submissions on same day should be allowed\"\n        repeat_data = response_repeat.json()\n        assert \"id\" in repeat_data\n        created_ids.append((url, repeat_data[\"id\"]))\n\n    finally:\n        # Cleanup: delete created resources to keep test environment clean\n        for url_base, resource_id in created_ids:\n            try:\n                delete_url = f\"{url_base}/{resource_id}\"\n                del_response = requests.delete(delete_url, headers=HEADERS, timeout=TIMEOUT)\n                assert del_response.status_code == 200 or del_response.status_code == 204, (\n                    f\"Failed to delete resource {resource_id} at {delete_url}\"\n                )\n            except Exception as e:\n                # Log but do not fail cleanup if deletion fails\n                print(f\"Warning: could not delete resource {resource_id} at {delete_url}. Exception: {e}\")\n\n\ntest_indicator_data_submission_forms_validation_and_submission()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 140, in <module>\n  File \"<string>\", line 99, in test_indicator_data_submission_forms_validation_and_submission\nAssertionError: Expected validation error for invalid payload at http://localhost:5174/api/lancamentos/taf, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.815Z",
    "modified": "2026-01-29T04:43:04.966Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "cd6871d6-9192-46b1-a488-d8d91819749a",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC009-test history table pagination and filtering",
    "description": "Verify the history table component for correct server-side pagination, filtering by indicator and period, and proper display of historical launch records with permission-based actions.",
    "code": "import requests\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\nAPI_KEY = \"your_api_key_here\"\nBEARER_TOKEN = \"your_bearer_token_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_history_table_pagination_and_filtering():\n    # Prepare filter parameters\n    indicator = \"TAF\"  # Typical indicator example\n    today = datetime.utcnow().date()\n    period_start = (today - timedelta(days=30)).isoformat()\n    period_end = today.isoformat()\n\n    page_size = 20\n\n    try:\n        # Step 1: Test pagination with filter indicators and period using GET with query params\n\n        params_page_1 = {\n            \"indicator\": indicator,\n            \"periodStart\": period_start,\n            \"periodEnd\": period_end,\n            \"page\": 1,\n            \"pageSize\": page_size\n        }\n        response_1 = requests.get(\n            f\"{BASE_URL}/history\",\n            headers=HEADERS,\n            params=params_page_1,\n            timeout=TIMEOUT\n        )\n        assert response_1.status_code == 200, f\"Expected 200 OK, got {response_1.status_code}\"\n        data_1 = response_1.json()\n        assert isinstance(data_1, dict), \"Response should be a dict\"\n        assert \"records\" in data_1, \"'records' key missing in response\"\n        assert isinstance(data_1[\"records\"], list), \"'records' should be a list\"\n        assert len(data_1[\"records\"]) <= page_size, f\"Returned records exceed page size {page_size}\"\n\n        # Validate records match filter criteria if any records exist\n        for record in data_1[\"records\"]:\n            assert \"indicator\" in record, \"Record missing 'indicator' field\"\n            assert record[\"indicator\"] == indicator, f\"Record indicator mismatch: expected {indicator}\"\n            assert \"date\" in record, \"Record missing 'date' field\"\n            record_date = record[\"date\"][:10]\n            assert period_start <= record_date <= period_end, f\"Record date {record_date} outside filter range\"\n\n            assert \"actions\" in record or \"canEdit\" in record or \"canDelete\" in record, \"Permission-based actions info missing\"\n\n        # Step 2: Test pagination page 2 if enough records exist on page 1\n        if len(data_1[\"records\"]) == page_size:\n            params_page_2 = params_page_1.copy()\n            params_page_2[\"page\"] = 2\n            response_2 = requests.get(\n                f\"{BASE_URL}/history\",\n                headers=HEADERS,\n                params=params_page_2,\n                timeout=TIMEOUT\n            )\n            assert response_2.status_code == 200, f\"Expected 200 OK on page 2, got {response_2.status_code}\"\n            data_2 = response_2.json()\n            assert isinstance(data_2, dict), \"Response on page 2 should be a dict\"\n            assert \"records\" in data_2, \"'records' key missing in page 2 response\"\n            assert isinstance(data_2[\"records\"], list), \"'records' on page 2 should be a list\"\n\n            records_page_1_ids = {r.get(\"id\") for r in data_1[\"records\"] if \"id\" in r}\n            records_page_2_ids = {r.get(\"id\") for r in data_2[\"records\"] if \"id\" in r}\n            assert not records_page_1_ids.intersection(records_page_2_ids), \"Records overlap between page 1 and page 2\"\n\n        # Step 3: Test filtering by a different indicator or period expecting empty or valid response\n        alternative_indicator = \"ProvaTeorica\"\n        alt_params = {\n            \"indicator\": alternative_indicator,\n            \"periodStart\": (today - timedelta(days=15)).isoformat(),\n            \"periodEnd\": today.isoformat(),\n            \"page\": 1,\n            \"pageSize\": page_size\n        }\n        response_alt = requests.get(\n            f\"{BASE_URL}/history\",\n            headers=HEADERS,\n            params=alt_params,\n            timeout=TIMEOUT\n        )\n        assert response_alt.status_code == 200, f\"Expected 200 OK for alternative filter, got {response_alt.status_code}\"\n        data_alt = response_alt.json()\n        assert \"records\" in data_alt, \"'records' key missing in alternative filter response\"\n        for record in data_alt[\"records\"]:\n            assert record[\"indicator\"] == alternative_indicator, f\"Alternative filter record indicator mismatch\"\n            rec_date = record[\"date\"][:10]\n            assert alt_params[\"periodStart\"] <= rec_date <= alt_params[\"periodEnd\"], \"Alternative filter record date outside range\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n    except AssertionError as ae:\n        raise ae\n\ntest_history_table_pagination_and_filtering()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 42, in test_history_table_pagination_and_filtering\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 106, in <module>\n  File \"<string>\", line 102, in test_history_table_pagination_and_filtering\nAssertionError: HTTP request failed: Expecting value: line 1 column 1 (char 0)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.820Z",
    "modified": "2026-01-29T04:43:24.834Z"
  },
  {
    "projectId": "fab61a28-33f6-4cdb-8e7a-9ed43b97d85f",
    "testId": "432dbfdf-bc5f-444f-8d79-82baffaed3a3",
    "userId": "44a824d8-d091-7084-bd81-3fd2735afff3",
    "title": "TC010-test user settings profile update and feedback submission",
    "description": "Ensure that the user settings page allows profile updates, password changes, and feedback submissions with proper validation and role-based access control.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5174\"\nTIMEOUT = 30\n\n# Replace these with valid tokens/keys for authentication\nBEARER_TOKEN = \"your_valid_bearer_token_here\"\nAPI_KEY = \"your_valid_api_key_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {BEARER_TOKEN}\",\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_user_settings_profile_update_and_feedback_submission():\n    session = requests.Session()\n    session.headers.update(HEADERS)\n\n    # Helper function: create a test feedback to be deleted after test\n    def create_feedback(feedback_payload):\n        response = session.post(f\"{BASE_URL}/user/settings/feedback\", json=feedback_payload, timeout=TIMEOUT)\n        response.raise_for_status()\n        return response.json().get(\"id\")\n\n    # Helper function: delete feedback by id\n    def delete_feedback(feedback_id):\n        if feedback_id:\n            resp = session.delete(f\"{BASE_URL}/user/settings/feedback/{feedback_id}\", timeout=TIMEOUT)\n            if resp.status_code not in [200, 204]:\n                raise Exception(f\"Failed to delete feedback id {feedback_id}: {resp.status_code} {resp.text}\")\n\n    # Helper function: retrieve current user profile info\n    def get_profile():\n        r = session.get(f\"{BASE_URL}/user/settings/profile\", timeout=TIMEOUT)\n        r.raise_for_status()\n        return r.json()\n\n    # Helper function: update user profile\n    def update_profile(payload):\n        r = session.put(f\"{BASE_URL}/user/settings/profile\", json=payload, timeout=TIMEOUT)\n        return r\n\n    # Helper function: change password\n    def change_password(payload):\n        r = session.post(f\"{BASE_URL}/user/settings/change-password\", json=payload, timeout=TIMEOUT)\n        return r\n\n    # Step 1: Get current profile data\n    profile = get_profile()\n    assert \"id\" in profile and \"email\" in profile, \"Profile retrieval failed or missing keys\"\n    user_id = profile[\"id\"]\n\n    # Prepare new profile data for update, toggle a field or change name temporarily\n    new_name = f\"Test User {uuid.uuid4().hex[:6]}\"\n    profile_update_payload = {\n        \"name\": new_name,\n        # Include other updatable fields as needed, assuming name is updatable\n    }\n\n    # Step 2: Update profile with valid data\n    response = update_profile(profile_update_payload)\n    assert response.status_code == 200, f\"Failed to update profile: {response.status_code} {response.text}\"\n    updated_profile = response.json()\n    assert updated_profile.get(\"name\") == new_name, \"Profile name not updated correctly\"\n\n    # Step 3: Attempt invalid profile update (e.g. invalid email format if email is updatable)\n    invalid_profile_payload = {\n        \"email\": \"invalid-email-format\"\n    }\n    response_invalid = update_profile(invalid_profile_payload)\n    # Expect validation error (likely 400 or 422)\n    assert response_invalid.status_code in [400,422], \"Invalid profile update was not rejected\"\n\n    # Step 4: Change password with valid data\n    # Assuming API requires old_password, new_password fields\n    valid_password_payload = {\n        \"old_password\": \"current_password_here\",\n        \"new_password\": \"NewP@ssw0rd2026\"\n    }\n    response_pass = change_password(valid_password_payload)\n    if response_pass.status_code == 403:\n        # Possibly old password invalid for this token; skip password change\n        pass\n    else:\n        assert response_pass.status_code == 200, f\"Password change failed: {response_pass.status_code} {response_pass.text}\"\n\n    # Step 5: Change password with invalid data (e.g. weak new password)\n    invalid_password_payload = {\n        \"old_password\": \"current_password_here\",\n        \"new_password\": \"short\"\n    }\n    response_pass_invalid = change_password(invalid_password_payload)\n    assert response_pass_invalid.status_code in [400,422], \"Weak password change was not rejected\"\n\n    # Step 6: Submit feedback with valid data and then delete it\n    feedback_payload = {\n        \"type\": \"suggestion\",\n        \"message\": f\"Automated test feedback message {uuid.uuid4()}\",\n        \"status\": \"new\"\n    }\n    feedback_id = None\n    try:\n        feedback_id = create_feedback(feedback_payload)\n        assert feedback_id is not None, \"Feedback creation did not return an ID\"\n\n        # Verify feedback retrieval (assuming feedback list endpoint)\n        r_feedbacks = session.get(f\"{BASE_URL}/user/settings/feedback\", timeout=TIMEOUT)\n        r_feedbacks.raise_for_status()\n        feedback_list = r_feedbacks.json()\n        assert any(f.get(\"id\") == feedback_id for f in feedback_list), \"Created feedback not found in feedback list\"\n\n        # Attempt invalid feedback submission (missing required fields)\n        invalid_feedback_payload = {\n            \"type\": \"\",  # invalid type empty\n            # missing message\n        }\n        resp_invalid_fb = session.post(f\"{BASE_URL}/user/settings/feedback\", json=invalid_feedback_payload, timeout=TIMEOUT)\n        assert resp_invalid_fb.status_code in [400,422], \"Invalid feedback submission was not rejected\"\n    finally:\n        # Clean up created feedback\n        delete_feedback(feedback_id)\n\n    # Step 7: Role-based access control check for profile update feedback endpoints\n    # Here assume that token belongs to authorized user; test forbidden update/delete for invalid id or forbidden resource.\n    forbidden_update_payload = { \"name\": \"Hacker Name\" }\n    # Attempt to update another user profile (simulate with made-up user ID)\n    forbidden_profile_update_resp = session.put(f\"{BASE_URL}/user/settings/profile/invalid-or-other-user-id\", json=forbidden_update_payload, timeout=TIMEOUT)\n    # Depending on API design, could be 404 or 403\n    assert forbidden_profile_update_resp.status_code in [403,404], \"Unauthorized profile update was not blocked\"\n\n    # Attempt to delete feedback without permission (simulate with invalid feedback id)\n    forbidden_delete_response = session.delete(f\"{BASE_URL}/user/settings/feedback/invalid-or-other-feedback-id\", timeout=TIMEOUT)\n    assert forbidden_delete_response.status_code in [403,404], \"Unauthorized feedback deletion was not blocked\"\n\n\ntest_user_settings_profile_update_and_feedback_submission()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 52, in test_user_settings_profile_update_and_feedback_submission\n  File \"<string>\", line 38, in get_profile\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:5174/user/settings/profile\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-29T04:41:57.826Z",
    "modified": "2026-01-29T04:43:07.074Z"
  }
]
